import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

/**
 * SHLF Shared Convex Schema
 *
 * This schema is shared between:
 * - shlf-automations (Clio Manage Automations)
 * - shlf-ghl-automations (GoHighLevel Automations)
 *
 * IMPORTANT: Do not modify tables outside your scope
 * - Clio tables: clio_traces, clio_steps, clio_details
 * - GHL tables: ghl_traces, ghl_steps, ghl_details
 */

export default defineSchema({
  // ============================================
  // CLIO TABLES - For Clio Manage Automations
  // ============================================

  /**
   * Level 1 - Traces (top-level triggers)
   *
   * Each webhook or scheduled job creates one trace.
   * This is the parent record that links all related operations.
   */
  clio_traces: defineTable({
    // Primary identifier - UUID generated by the app
    traceId: v.string(),

    // Source of the trigger
    source: v.union(v.literal("webhook"), v.literal("job")),

    // Name of the automation/trigger
    // e.g., "matter-stage-change", "task-completion", "token-refresh"
    triggerName: v.string(),

    // Webhook endpoint (for webhooks)
    // e.g., "/webhooks/matters", "/webhooks/tasks"
    endpoint: v.optional(v.string()),

    // Clio matter ID (when applicable)
    matterId: v.optional(v.number()),

    // Original webhook ID from Clio
    webhookId: v.optional(v.string()),

    // For scheduled jobs - the job name
    jobName: v.optional(v.string()),

    // Timestamps (Unix milliseconds)
    dateStarted: v.number(),
    dateFinished: v.optional(v.number()),

    // Processing status
    status: v.union(
      v.literal("in_progress"),
      v.literal("success"),
      v.literal("error"),
      v.literal("skipped")
    ),

    // Duration in milliseconds
    durationMs: v.optional(v.number()),

    // Error message if status is "error"
    errorMessage: v.optional(v.string()),

    // Result action taken
    // e.g., "tasks_created", "skipped_test_mode", "skipped_already_processed"
    resultAction: v.optional(v.string()),

    // Input data (what was received/triggered the trace)
    input: v.optional(v.any()),

    // Output data (what was produced/returned)
    output: v.optional(v.any()),

    // Additional context data
    metadata: v.optional(v.any()),
  })
    .index("by_traceId", ["traceId"])
    .index("by_matterId", ["matterId"])
    .index("by_source", ["source"])
    .index("by_triggerName", ["triggerName"])
    .index("by_dateStarted", ["dateStarted"])
    .index("by_status", ["status"]),

  /**
   * Level 2 - Steps (layer operations)
   *
   * Each major operation within a trace creates a step.
   * Groups related details together by layer.
   */
  clio_steps: defineTable({
    // Primary identifier - UUID generated by the app
    stepId: v.string(),

    // Reference to parent trace
    traceId: v.string(),

    // Layer name for categorization
    // e.g., "webhook", "processing", "automation", "service", "external"
    layerName: v.string(),

    // Step name describing the operation
    // e.g., "idempotency_check", "fetch_matter", "generate_tasks"
    stepName: v.string(),

    // Order within the trace (auto-incrementing)
    stepOrder: v.optional(v.number()),

    // Timestamps (Unix milliseconds)
    dateStarted: v.number(),
    dateFinished: v.optional(v.number()),

    // Processing status
    status: v.union(
      v.literal("in_progress"),
      v.literal("success"),
      v.literal("error"),
      v.literal("skipped")
    ),

    // Duration in milliseconds
    durationMs: v.optional(v.number()),

    // Error message if status is "error"
    errorMessage: v.optional(v.string()),

    // Input data (what was passed to this step)
    input: v.optional(v.any()),

    // Output data (what this step produced)
    output: v.optional(v.any()),

    // Additional context data
    metadata: v.optional(v.any()),
  })
    .index("by_stepId", ["stepId"])
    .index("by_traceId", ["traceId"])
    .index("by_layerName", ["layerName"])
    .index("by_dateStarted", ["dateStarted"]),

  /**
   * Level 3 - Details (individual operations)
   *
   * Each atomic operation (API call, DB query, calculation) creates a detail.
   * Provides granular visibility into what happened.
   */
  clio_details: defineTable({
    // Primary identifier - UUID generated by the app
    detailId: v.string(),

    // Reference to parent step
    stepId: v.string(),

    // Reference to root trace (for efficient queries)
    traceId: v.string(),

    // Operation name
    // e.g., "clio_getMatter", "supabase_getTaskList", "resolve_assignee"
    operation: v.string(),

    // Type of operation for categorization
    operationType: v.union(
      v.literal("api_call"),      // External API calls (Clio, etc.)
      v.literal("db_query"),      // Database read operations
      v.literal("db_mutation"),   // Database write operations
      v.literal("validation"),    // Input/data validation
      v.literal("calculation"),   // Due date, assignee resolution, etc.
      v.literal("decision"),      // Branching logic, conditionals
      v.literal("external_call")  // Other external service calls
    ),

    // Input parameters (sanitized - no sensitive data)
    input: v.optional(v.any()),

    // Output/result (sanitized - no sensitive data)
    output: v.optional(v.any()),

    // Duration in milliseconds
    durationMs: v.optional(v.number()),

    // Operation status
    status: v.union(
      v.literal("success"),
      v.literal("error"),
      v.literal("skipped")
    ),

    // Error message if status is "error"
    errorMessage: v.optional(v.string()),

    // Timestamp of this specific operation
    timestamp: v.number(),
  })
    .index("by_detailId", ["detailId"])
    .index("by_stepId", ["stepId"])
    .index("by_traceId", ["traceId"])
    .index("by_operation", ["operation"])
    .index("by_operationType", ["operationType"])
    .index("by_timestamp", ["timestamp"]),

  // ============================================
  // GHL TABLES - For GoHighLevel Automations
  // ============================================

  /**
   * GHL Traces - Parent level (Webhook/Cron triggers)
   */
  ghl_traces: defineTable({
    // Unique trace identifier (format: trc_[timestamp]_[random])
    traceId: v.string(),

    // Trigger identification
    triggerType: v.union(v.literal("webhook"), v.literal("cron")),
    endpoint: v.string(),
    httpMethod: v.string(),

    // Request data
    requestHeaders: v.optional(v.any()),
    requestBody: v.optional(v.any()),
    requestQuery: v.optional(v.any()),
    requestIp: v.optional(v.string()),

    // Response data
    responseStatus: v.optional(v.number()),
    responseBody: v.optional(v.any()),

    // Extracted context IDs (for easier querying)
    contactId: v.optional(v.string()),
    opportunityId: v.optional(v.string()),
    invoiceId: v.optional(v.string()),
    appointmentId: v.optional(v.string()),

    // Status and timing
    status: v.union(
      v.literal("started"),
      v.literal("completed"),
      v.literal("failed"),
      v.literal("partial")
    ),
    startTime: v.number(),
    endTime: v.optional(v.number()),
    durationMs: v.optional(v.number()),

    // Error information
    error: v.optional(
      v.object({
        message: v.string(),
        stack: v.optional(v.string()),
        code: v.optional(v.string()),
        raw: v.optional(v.any()),
      })
    ),

    // Metadata
    environment: v.optional(v.string()),
    serverVersion: v.optional(v.string()),

    // Counts for quick overview
    stepCount: v.optional(v.number()),
    detailCount: v.optional(v.number()),
    errorCount: v.optional(v.number()),
  })
    .index("by_traceId", ["traceId"])
    .index("by_endpoint", ["endpoint"])
    .index("by_status", ["status"])
    .index("by_startTime", ["startTime"])
    .index("by_contactId", ["contactId"])
    .index("by_opportunityId", ["opportunityId"])
    .index("by_invoiceId", ["invoiceId"])
    .index("by_appointmentId", ["appointmentId"])
    .index("by_endpoint_startTime", ["endpoint", "startTime"]),

  /**
   * GHL Steps - Children (Service layer calls)
   */
  ghl_steps: defineTable({
    // Step identifier (format: stp_[trace-suffix]_[sequence])
    stepId: v.string(),

    // Parent trace reference
    traceId: v.string(),

    // Service identification
    serviceName: v.string(),
    functionName: v.string(),

    // Execution order within trace
    sequence: v.number(),

    // Input/Output
    input: v.optional(v.any()),
    output: v.optional(v.any()),

    // Status and timing
    status: v.union(
      v.literal("started"),
      v.literal("completed"),
      v.literal("failed"),
      v.literal("skipped")
    ),
    startTime: v.number(),
    endTime: v.optional(v.number()),
    durationMs: v.optional(v.number()),

    // Error information
    error: v.optional(
      v.object({
        message: v.string(),
        stack: v.optional(v.string()),
        code: v.optional(v.string()),
        raw: v.optional(v.any()),
      })
    ),

    // Context passed through
    contextData: v.optional(v.any()),

    // Child detail count
    detailCount: v.optional(v.number()),
  })
    .index("by_stepId", ["stepId"])
    .index("by_traceId", ["traceId"])
    .index("by_traceId_sequence", ["traceId", "sequence"])
    .index("by_serviceName", ["serviceName"])
    .index("by_functionName", ["functionName"])
    .index("by_status", ["status"]),

  /**
   * GHL Details - Grandchildren (Individual operations/API calls)
   */
  ghl_details: defineTable({
    // Detail identifier (format: dtl_[step-suffix]_[sequence])
    detailId: v.string(),

    // Parent references
    traceId: v.string(),
    stepId: v.string(),

    // Detail type
    detailType: v.union(
      v.literal("api_call"),
      v.literal("db_query"),
      v.literal("internal"),
      v.literal("webhook_out"),
      v.literal("ai_call")
    ),

    // Execution order within step
    sequence: v.number(),

    // For API calls
    apiProvider: v.optional(v.string()),
    apiEndpoint: v.optional(v.string()),
    apiMethod: v.optional(v.string()),

    // Request data (for API calls)
    requestHeaders: v.optional(v.any()),
    requestBody: v.optional(v.any()),
    requestQuery: v.optional(v.any()),

    // Response data
    responseStatus: v.optional(v.number()),
    responseBody: v.optional(v.any()),
    responseHeaders: v.optional(v.any()),

    // For internal operations
    operationName: v.optional(v.string()),
    operationInput: v.optional(v.any()),
    operationOutput: v.optional(v.any()),

    // Status and timing
    status: v.union(
      v.literal("started"),
      v.literal("completed"),
      v.literal("failed")
    ),
    startTime: v.number(),
    endTime: v.optional(v.number()),
    durationMs: v.optional(v.number()),

    // Error information
    error: v.optional(
      v.object({
        message: v.string(),
        stack: v.optional(v.string()),
        code: v.optional(v.string()),
        httpStatus: v.optional(v.number()),
        raw: v.optional(v.any()),
      })
    ),
  })
    .index("by_detailId", ["detailId"])
    .index("by_traceId", ["traceId"])
    .index("by_stepId", ["stepId"])
    .index("by_stepId_sequence", ["stepId", "sequence"])
    .index("by_apiProvider", ["apiProvider"])
    .index("by_detailType", ["detailType"])
    .index("by_status", ["status"]),
});
